//import java.util.ArrayList;
//import java.util.Iterator;
//import java.util.List;
//
//public class PatternCombinatorOld {
//
//    /**
//     * The criteria according to which an fst.FST is a combination
//     * of two other FSTs.
//     * STRICT_MATCH: The two other FSTs must generate the exact
//     * same output from the literal input.
//     * LAX_MATCH: The two other FSTs must generate the exact same
//     * output from the input, interpreting a dot as any char they
//     * accept.
//     * LAX_APPROX: In both input and output, dots may be interpreted
//     * as any char.
//     */
//    public enum Mode { STRICT_MATCH, LAX_MATCH, LAX_APPROX }
//
//    /**
//     * Removes all FSTs that are combinations of two other FSTs, i.e.
//     * whose output may be generated by a chain of two other FSTs when
//     * given the same input.
//     * @param original The FSTs to check
//     * @return A list of FSTs that were removed
//     */
//    public static List<fst.FST> removeCombinations(List<fst.FST> original) {
//        // The FSTs that were removed
//        List<fst.FST> removed = new ArrayList<>();
//        // The FSTs that were reweighed
//        List<fst.FST> blocked = new ArrayList<>();
//
//        // Sort FSTs according to weight, so that the lower weighed
//        // FSTs are checked first
//        original.sort(new fst.FST.PatternWeightAscendingComparator());
//
//        for (Iterator<fst.FST> iter = original.iterator(); iter.hasNext();) {
//            fst.FST fst = iter.next();
//            String[] pattern = util.StringUtils.split(fst.getPattern(), ' ');
//
//            // Do not check identity FSTs that only change POS
//            if (pattern.length != 2) {
//
//                // Get input and output side of the current fst.FST
//                StringBuilder inBuild = new StringBuilder();
//                StringBuilder outBuild = new StringBuilder();
//                for (int i = 0; i < pattern.length - 1; i++) {
//                    char in = pattern[i].charAt(0);
//                    char out = pattern[i].charAt(2);
//                    if (in != '-')
//                        inBuild.append(in);
//                    if (out != '-')
//                        outBuild.append(out);
//                }
//                String input = inBuild.append(':').append(fst.getFromPos()).toString();
//                String output = outBuild.append(':').append(fst.getToPos()).toString();
//
//                //System.out.println("--------------------------------");
//                //System.out.println(fst.getPattern() + " -> " + input + " / " + output);
//
//                // First, check whether this fst.FST can be clearly identified as a
//                // comination using strict match mode. If true, remove it.
//                if (isCombination(fst, input, output, original, Mode.STRICT_MATCH)) {
//                    //System.out.println("clear");
//                    removed.add(fst);
//                    iter.remove();
//                }
//                // If strict match yielded no clear results, try in lax mode, i.e. inter-
//                // pret dots in input as any char instead of a literal.
//                else {
//                    // If this fst.FST can output any String, i.e. its output is just ".",
//                    // it makes no sense to do a lax approximation, because this will
//                    // return true for any two FSTs. So in this case, the two FSTs must
//                    // at least also output just a dot. If the output is more informative,
//                    // dots may be interpreted as any char.
//                    boolean isComb = (output.indexOf(':') > 1)
//                            ? isCombination(fst, input, output, original, Mode.LAX_APPROX)
//                            : isCombination(fst, input, output, original, Mode.LAX_MATCH);
//                    // If this yields a matching combination, reweigh the fst.FST by 1/10 to
//                    // mark it as questionable. It is not removed entirely, because we
//                    // cannot really be sure it is a combination with lax mode. Also, the
//                    // dubious fst.FST is blocked from serving as a combining fst.FST in the further
//                    // process.
//                    if (isComb) {
//                        //System.out.println("dubious");
//                        fst.setWeight(fst.getWeight()/10);
//                        blocked.add(fst);
//                        iter.remove();
//                    }
//                }
//            }
//        }
//        // Put all dubious FSTs back into the list
//        original.addAll(blocked);
//        // Sort according to weight
//        original.sort(new fst.FST.PatternWeightDescendingComparator());
//        // Return removed FSTs
//        return removed;
//    }
//
//    private static boolean isCombination(fst.FST fst, String input, String output, List<fst.FST> original, Mode mode) {
//        boolean parseDots = (mode == Mode.STRICT_MATCH) ? false : true;
//        boolean isComb = false;
//        for (int i = 0; !isComb && i < original.size(); i++) {
//            fst.FST fst1 = original.get(i);
//            if (fst != fst1) {
//                for (int j = i + 1; !isComb && j < original.size(); j++) {
//                    fst.FST fst2 = original.get(j);
//                    if (fst != fst2) {
//                        String mid = fst1.apply(input, parseDots);
//                        //System.out.print(fst1.getPattern() + " -> " + mid);
//                        //System.out.println(" && " + fst2.getPattern() + " -> " + fst2.apply(mid, parseDots));
//                        if (!mid.isEmpty()) isComb = (mode == Mode.LAX_APPROX)
//                                ? fst.generates(fst2.apply(mid, parseDots))
//                                : fst2.apply(mid, parseDots).equals(output);
//                        if (!isComb) {
//                            mid = fst2.apply(input, parseDots);
//                            //System.out.print(fst2.getPattern() + " -> " + mid);
//                            //System.out.println(" && " + fst1.getPattern() + " -> " + fst1.apply(mid, parseDots));
//                            if (!mid.isEmpty()) isComb = (mode == Mode.LAX_APPROX)
//                                    ? fst.generates(fst1.apply(mid, parseDots))
//                                    : fst1.apply(mid, parseDots).equals(output);
//                        }
//                    }
//                }
//            }
//        }
//        return isComb;
//    }
//}
